#!/usr/bin/env python3

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List

import os
import subprocess

# dotfiles-openjck-setup:
# Set up dotfile dependencies.
#
# Installation instructions:
# https://github.com/openjck/dotfiles/blob/main/docs/scripts.md#installation
#
# Usage instructions:
# https://github.com/openjck/dotfiles/blob/main/docs/scripts.md#usage

# MIT License
#
# Copyright (c) 2023, 2024, 2025 John Karahalis
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

@dataclass
class Step():
    term: str
    own_activity_output: bool = False

class Result(Enum):
    DONE = 1
    ALREADY_DONE = 2
    UNSUPPORTED = 3

home = Path.home()
xdg_config_home = os.environ['XDG_CONFIG_HOME']


# Run a command and print both stdout and stderr.
def run(cmd):
    return subprocess.run(cmd, shell=True)


# Run a command, but do not print stdout. DO print stderr, if any.
def run_quietly(cmd):
    return subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL)


# Run a command and print nothing, not even stderr.
def run_silently(cmd):
    return subprocess.run(
        cmd,
        shell=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def set_up_packages_apt():
    # Just an example
    return Result.ALREADY_DONE


def set_up_packages():
    match os.environ['DISTRO']:
        case 'Ubuntu' | 'Debian':
            return set_up_packages_apt()
        case _:
            return Result.UNSUPPORTED


def set_up_flatpaks():
    installed_any = False

    # Set up remotes, including one remote for Flathub and one remote for
    # verified flatpaks on Flathub.
    run_quietly(
        'flatpak remote-add --if-not-exists flathub ' +
        'https://dl.flathub.org/repo/flathub.flatpakrepo'
    )
    run_quietly(
        'flatpak remote-add --if-not-exists --subset=verified ' +
        'flathub-verified https://flathub.org/repo/flathub.flatpakrepo'
    )

    flatpaks_to_install = {
        'verified': [
            'org.mozilla.firefox'
        ],
        'unverified': [
        ],
    }

    for verification_type, flatpaks in flatpaks_to_install.items():
        if verification_type == 'verified':
            remote = 'flathub-verified'
        else:
            remote = 'flathub'

        for flatpak in flatpaks:
            proc = run_silently(f'flatpak info {flatpak}')

            if proc.returncode != 0:
                # Print a newline before the first flatpak to be installed so
                # that any output appears below "Setting up flatpaks...". Also
                # ensure the newline is printed _only_ for the first flatpak to
                # be installed so that subsequent installation output is not
                # separated by newlines.
                if not installed_any:
                    print()
                run(f'flatpak install --noninteractive {remote} {flatpak}')
                installed_any = True

    if installed_any:
        return Result.DONE
    else:
        return Result.ALREADY_DONE


def set_up_snaps():
    if os.environ['DISTRO'] != 'Ubuntu':
        return Result.UNSUPPORTED

    installed_any = False

    @dataclass
    class Snap():
        name: str
        flags: List[str]

    snaps_to_install = [
        Snap('nvim', ['--classic'])
    ]

    for snap in snaps_to_install:
        proc = run_silently(f'snap list {snap.name}')

        if proc.returncode != 0:
            # Print a newline before the first snap to be installed so that any
            # output appears below "Setting up snaps...". Also ensure the
            # newline is printed _only_ for the first snap to be installed so
            # that subsequent installation output is not separated by newlines.
            if not installed_any:
                print()
            run(f'sudo snap install {snap.name} {" ".join(snap.flags)}')
            installed_any = True

    if installed_any:
        return Result.DONE
    else:
        return Result.ALREADY_DONE



def set_up_vcsh():
    # Just an example
    return Result.DONE


def set_up_directories():
    created_any = False

    paths_to_create = [
        Path(f'{home}/LGTD/inboxes/main'),
        Path(f'{home}/apps/repos/git'),
        Path(f'{home}/apps/appimage'),
        Path(f'{home}/bin/local'),
        Path(f'{home}/bin/local/downloaded'),
        Path(f'{home}/bin/local/temporary'),
        Path(f'{home}/devel'),
        Path(f'{home}/devel/repos'),
        Path(f'{xdg_config_home}/bash/init/functions/local'),
    ]

    for path in paths_to_create:
        if not path.is_dir():
            path.mkdir(parents=True)
            created_any = True

    if created_any:
        return Result.DONE
    else:
        return Result.ALREADY_DONE


def set_up_tmux():
    tpm_dir = Path(f'{home}/.tmux/plugins/tpm')

    if tpm_dir.is_dir():
        return Result.ALREADY_DONE
    else:
        print()

        # Install tpm.
        run(f'git clone --quiet https://github.com/tmux-plugins/tpm {tpm_dir}')

        # Install plugins
        run(f'{tpm_dir}/bin/install_plugins')

        return Result.DONE


def run_steps(steps):
    longest_term_length = max(map(lambda s: len(s.term), steps))

    for step in steps:
        run_step(step, longest_term_length)


def run_step(step, longest_term_length):
    term_suffix = '... '
    pad_length = longest_term_length + len(term_suffix)
    padded_term_and_suffix = (step.term + term_suffix).ljust(pad_length)

    print(f'Setting up {padded_term_and_suffix}', end='', flush=True)

    setup_fn_name = f'set_up_{step.term}'
    result = globals()[setup_fn_name]()

    match result:
        case Result.DONE:
            if not step.own_activity_output:
                print('done.')
        case Result.ALREADY_DONE:
            print('already done.')
        case Result.UNSUPPORTED:
            print('unsupported.')


# TODO: Put this into something like a main function.
steps = [
    Step('packages', own_activity_output=True),
    Step('flatpaks', own_activity_output=True),
    Step('snaps', own_activity_output=True),
    Step('vcsh'),
    Step('directories'),
    Step('tmux', own_activity_output=True),
]

run_steps(steps)
