#!/usr/bin/env bash

# Use "strict mode."
#
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail

COMMAND_NAME=$(basename "$0")

eval "$(docopts --help=- -A ARGS : "$@" <<EOF
Recursively replace a string or pattern with a given string, modifying all files
in the current directory and all subdirectories.

Usage:
  $COMMAND_NAME SEARCH REPLACE
  $COMMAND_NAME -h | --help

Examples:
  $COMMAND_NAME "John.*?Karahalis" "JK"

Options:
  -h, --help
      Show this documentation
EOF
)"

# This works, but if it becomes unwieldy in the future, it could potentially be
# made simpler (and support a more common regex style) by using sd and fd
# instead.
#
# https://github.com/chmln/sd#quick-guide
grep \
  --recursive \
  --files-with-matches \
  --perl-regexp \
  "${ARGS[SEARCH]}" \
  | xargs sed \
    --in-place \
    --regexp-extended \
    "s/${ARGS[SEARCH]}/${ARGS[REPLACE]}/g"
