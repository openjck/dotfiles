#!/usr/bin/env bash

# rsync-mirror:
# Update TARGET to perfectly match SOURCE.
#
# Installation instructions:
# https://github.com/openjck/dotfiles/blob/main/docs/scripts.md#installation
#
# Usage instructions:
# https://github.com/openjck/dotfiles/blob/main/docs/scripts.md#usage

# MIT License
#
# Copyright (c) 2023, 2024, 2025, 2026 John Karahalis
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Use Bash's unofficial "strict mode."
#
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -o errexit
set -o nounset
set -o pipefail

COMMAND_NAME=$(basename "$0")

##########################
# BEGIN DEPENDENCY CHECK #
##########################

DEPENDENCIES=(
  docopts
  rsync
)

MISSING_DEPENDENCIES=()

for DEPENDENCY in "${DEPENDENCIES[@]}"; do
  if ! command -v "$DEPENDENCY" > /dev/null; then
    MISSING_DEPENDENCIES+=("$DEPENDENCY")
  fi
done

if (( ${#MISSING_DEPENDENCIES[@]} > 0 )); then
  >&2 fold --spaces <<EOF
FATAL ERROR: The following are not installed. You must install them on your \
own for "$COMMAND_NAME" to function properly.

EOF
  for DEPENDENCY in "${MISSING_DEPENDENCIES[@]}"; do
    >&2 echo "  - $DEPENDENCY"
  done
  exit 1
fi

########################
# END DEPENDENCY CHECK #
########################

eval "$(docopts --help=- -A ARGS : "$@" <<EOF
Update TARGET to perfectly match SOURCE.

Files in TARGET are deleted if they do not exist in SOURCE.

SOURCE and TARGET may be specified with or without trailing slashes without
affecting the result.

Usage:
  $COMMAND_NAME [--read-source-with-sudo] [--exclude=PATTERN...] SOURCE TARGET
  $COMMAND_NAME -h | --help

Examples:
  $COMMAND_NAME /media/john/drive /media/john/some-other-drive
  $COMMAND_NAME john@example.com:/home/john /media/john/backup/example.com

Options:
  -s, --read-source-with-sudo
      Use "sudo" on the SOURCE machine when reading files from SOURCE. This can
      be helpful when, among other things, mirroring the root directory of
      a remote machine. If this option were not passed when doing so, some files
      would not be able to be mirrored from the remote machine because they had
      restrictive permissions.
  --exclude=PATTERN
      Exclude files matching PATTERN. These work exactly as they do in rsync.
      One or more of these options can be passed.
  -h, --help
      Show this documentation
EOF
)"

SOURCE_WITH_NO_TRAILING_SLASH=${ARGS[SOURCE]%/}
TARGET_WITH_NO_TRAILING_SLASH=${ARGS[TARGET]%/}

SOURCE_WITH_TRAILING_SLASH=$SOURCE_WITH_NO_TRAILING_SLASH/
TARGET_WITH_TRAILING_SLASH=$TARGET_WITH_NO_TRAILING_SLASH/

# rsync will create the destination directory if it does not already exist.
# That's often fine, but it's not what I'd like this script to do. Rather, I'd
# like this script to exit with an error message if the destination directory
# cannot be found. I often use this script to synchronize two external backup
# drives, and I don't want a new copy of a backup to be made on the _local_ disk
# if the external disk cannot be found.
#
# Perhaps this behavior, checking whether the destination directory exists, can
# be made an option in the future, perhaps disabled by default.
#
# ${ARGS[TARGET]} is used so that the path that appears in the error message has
# the same format as the argument provided as TARGET, whether TARGET was written
# _with_ a trailing slash or _without_ a trailing slash. That just adds a bit of
# clarity, so that the user doesn't wonder if the path that was _checked_ was
# any different from the path they _provided_.
if [[ ! -d "${ARGS[TARGET]}" ]]; then
    >&2 fold --spaces \
      <<< "FATAL ERROR: \"${ARGS[TARGET]}\" does not exist."
    exit 1
fi

RSYNC_OPTIONS=(
  --archive
  --delete
  --hard-links
  --acls
  --xattrs
  --verbose
)

if [[ ${ARGS[--read-source-with-sudo]} ]]; then
  RSYNC_OPTIONS+=(--rsync-path='sudo rsync')
fi

I=0
while (( I < ${ARGS[--exclude,#]} )); do
  EXCLUDE_VALUE=${ARGS[--exclude,$I]}
  RSYNC_OPTIONS+=(--exclude="$EXCLUDE_VALUE")
  I=$((I + 1))
done

# When both the source and the destination have a trailing slash, rsync updates
# the destination to have the same _contents_ as the source, rather than
# updating the destination to have a directory with the same name and same
# contents as the source directory.
#
# https://stackoverflow.com/a/31278462/715866
rsync \
  "${RSYNC_OPTIONS[@]}" \
  "$SOURCE_WITH_TRAILING_SLASH" \
  "$TARGET_WITH_TRAILING_SLASH"
