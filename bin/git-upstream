#!/usr/bin/env bash

# Use "strict mode."
#
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail

COMMAND_NAME=$(basename "$0")
GIT_SUBCOMMAND_NAME=${COMMAND_NAME/git-/}

eval "$(docopts --help=- -A ARGS : "$@" <<EOF
Print the name of the upstream Git branch or print nothing and return with an
error code if there is no upstream Git branch.

If this script exists somewhere along the \$PATH, it can be used as a Git
subcommand, like so:

  git $GIT_SUBCOMMAND_NAME

When used as a Git subcommand, the command accepts the same arguments and
behaves in the same way.

Usage:
  $COMMAND_NAME
  $COMMAND_NAME -h | --help

Options:
  -h --help  Show this documentation
EOF
)"

# This script is based on the following Stack Overflow answer:
# https://stackoverflow.com/a/9753364/715866

# Running "git rev-parse" prints an error if we are not in a Git repo. If the
# command is successful, however, it is silent and we continue.
if git rev-parse; then
  # Redirect stderr to /dev/null to avoid printing error if there is no upstream
  # branch. Note that this script will nonetheless return with an error code if
  # there is no upstream branch.
  git rev-parse --abbrev-ref --symbolic-full-name "@{upstream}" 2> /dev/null
fi
